% Author: Matej MiŠtík <xmisti00@stud.fit.vutbr.cz>


\documentclass[a4paper, 11pt]{article}


\usepackage[T1]{fontenc} 
\usepackage[czech]{babel}
\usepackage[utf8]{inputenc}
\usepackage[left=2cm, top=3cm, text={17cm, 24cm}]{geometry}
\usepackage{times}
\usepackage{verbatim}
\usepackage{enumitem}
\usepackage{graphicx} % vkládání obrázků
\usepackage[unicode]{hyperref}
\hypersetup{
	colorlinks = true,
	hypertexnames = false,
	citecolor = green
}


\newcommand{\RNum}[1]{\uppercase\expandafter{\romannumeral #1\relax}} % makro na sázení římských čísel


\begin{document}


	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Titulní stránka %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{titlepage}
		\begin{center}
			\includegraphics[width=0.77\linewidth]{img/FIT_logo.pdf} \\

			\vspace{\stretch{0.15}}

			\Huge{Formální jazyky a překladače} \\
			\bigskip
			\Huge{Projektová dokumentace}\\
			\smallskip
			\LARGE{\textbf{Implementace překladače jazyka IFJ20}} \\
			\Large{Tým 30, varianta \RNum{2}}\\
			{\scriptsize Rozšířeni BASE,BOOLTHEN,UNARY \par}
			\vspace{\stretch{0.618}}
		\end{center}

		\begin{minipage}{0.4 \textwidth}
			{\Large \today}
		\end{minipage}
		\hfill
		\begin{minipage}[r]{0.55 \textwidth}
			\Large
			\begin{tabular}{l l l}
				\textbf{Filip Solich} & \textbf{(xsolic00)} & \quad 25\,\% \\
				 Marek Sechra & (xsechr00) & \quad 25\,\% \\
				 Andrej Baáš  & (xbaasa00) & \quad 25\,\% \\
				Matej MiŠtík  & (xmisti00) & \quad 25\,\% \\
			\end{tabular}
		\end{minipage}
	\end{titlepage}



	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Obsah %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\pagenumbering{roman}
	\setcounter{page}{1}
	\tableofcontents
	\clearpage



	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Úvod %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\pagenumbering{arabic}
	\setcounter{page}{1}
	
	\section{Úvod}

	Cílem projektu bylo vytvořit program v~jazyce~C, který načte zdrojový kód zapsaný ve zdrojovém jazyce IFJ20,
	jenž je zjednodušenou podmnožinou jazyka GO a~přeloží jej do finálního mezikódu IFJcode20.
 
  \section{Etapy projektu}
    \begin{enumerate}
  \item Návrh struktury programu konečný automat ( obrázek \ref{figure:automat}),LL-tabulka ( tabulka \ref{table:ll_table} ),\newline LL gramatika ( tabulka \ref{table:ll_gramatika} ), precedenční tabulka ( tabulka \ref{table:prec_table} )
  \vspace{-0.6em}
  \item Lexikální analýza
  \vspace{-0.6em}
  \item Syntaktická analýza podľa LL Gramatiky
  \vspace{-0.6em}
  \item Precedenční syntaktická analýza 
  \vspace{-0.6em}
  \item Generování kódu
  \vspace{-0.6em}
  \item Testování
  \vspace{-0.6em}
  \item Tvorba dokumentace
  \vspace{-0.6em}
    \end{enumerate}


	\section{Lexikální analýza - Filip}
    Lexikální analyzátor ( scanner ) představovala první část projektu, kterou bylo nutno implementovat. 
    Produktem LA je datová struktura \verb|token_t|, se kterou se pak dále pracuje v ostatních částech překladače.
	
	Lexikální analyzátor je implementován jako deterministický konečný automat.V jazyce implementovaný pomocí nekonečného \texttt{switch}, kde každý případ
	\texttt{case} je ekvivalentní jenom k~jednomu stavu automatu. Pokud načtený znak nesouhlasí s~žádným znakem, který jazyk povoluje,
	program je ukončen a~vrací chybu 1  (chybná struktura aktuálního lexému). Jinak se přechází do dalších stavů a~načítají se další znaky, dokud nemáme hotový jeden
	token, který potom vracíme a~ukončíme tuto funkci.
	

	\section{Syntaktická analýza - Andrej skontrolovat}

    Syntaktická analýza je nejdůležitějším modulem překladačů protože řídí a závisí od ní ostatní moduly.

	Až na výrazy se syntaktická analýza řídí podle pravidel v~LL -- tabulce \ref{table:ll_gramatika}. Každé pravidlo LL Gramatiky má svou vlastní funkci, která dostává přes parametr ukazatel na \texttt{fdata},
	což je struktura obsahující proměnné nutné pro správné fungování analýzy. Syntaktická analýza žádá po lexikálním
	analyzátoru tokeny pomocí funkce \texttt{get\_next\_token}. Tyto tokeny načítá lexikální analyzátor ze standardtního vstupu
	a~zároveň provádí lexikální analýzu.

	Aby se příkaz návratu z~funkce nevyskytoval v~hlavním těle programu, ***

	\subsection{Zpracování výrazů pomocí precedenční syntaktické analýzy - Andrej -> potreba upravit podla seba}
	
	Precedenční analýza je v~syntaktické analýze definována a~volána jako ostatní pravidla v~LL -- gramatice implementovaná v \texttt{parser.c}

	Při zpracovávání výrazů je použita precedenční tabulka \ref{table:prec_table}. Jelikož operátory \texttt{+} a~– mají
	stejnou asociativitu a~prioritu, mohli jsme je zjednodušit do jednoho sloupce a~řádku tabulky \texttt{+ -}.
	Totéž jsme mohli udělat s~operátory \texttt{*} a~\texttt{/} (v~tabulce sloupec a~řádek \texttt{* /}) a~také
	všemi relačními operátory (v~tabulce sloupec a~řádek \texttt{r}). Řádek a~sloupec \texttt{i} symbolizuje
	identifikátor, číselnou hodnotu nebo řetězec. Pro získání indexu ze symbolu do tabulky jsme si vytvořili
	funkci \texttt{get\_prec\_table\_index}, které se jako parametr zadá symbol, a~vrátí index do tabulky.
	Mezi povolené symboly ve výrazech patří všechny operátory, literály, které jsou v~tabulce zastoupeny již
	dříve popsaným \texttt{i}, a~závorky. Tyto symboly jsou terminály. Všechny ostatní symboly, které výraz
	obsahovat nemůže, jsou zastoupeny symbolem \texttt{\$}. Řádky tabulky označují vrchní terminál v~zásobníku
	symbolů a~sloupce symbol v~aktuálním tokenu.

	Po spuštění analýzy se podle vrchního terminálu v~zásobníku symbolů a~symbolu aktuálního tokenu provádějí různé
	operace a~v~některých případech se volá funkce \texttt{get\_next\_token}.

	Pokud znak z~tabulky je \texttt{<}, vložíme zarážku za vrchní terminál, aktuální symbol vložíme na vrchol zásobníku
	a~zavoláme funkci \texttt{get\_next\_token}. Pokud znak z~tabulky je \texttt{>} a~existuje pravidlo, podle kterého
	se dají zredukovat položky zásobníku symbolů od nejvrchnější položky až po zarážku, tak je zredukujeme a~odstraníme
	zarážku. Během provádění redukce podle stanovených pravidel se otestuje sémantika levého a~pravého operandu a~pokud
	je to potřebné a~možné, provede se implicitní přetypování jednoho nebo obou operandů. Pokud znak je \texttt{=}, aktuální
	symbol vložíme na vrchol zásobníku a~zavoláme funkci \texttt{get\_next\_token}. To opakujeme až do chvíle, kdy na místě
	v~tabulce určeném vrchním terminálem v~zásobníku symbolů a~symbolem aktuálního tokenu žádný znak není. Pokud vrchní
	terminál i~aktuální symbol je \texttt{\$} a~na vrcholu zásobníku zůstal jeden výsledný neterminál, syntaktická analýza je
	úspěšná, v~jiných případech končí neúspěšně.



	
	\subsection{Sémantická analýza}

    Ve struktuře \texttt{fdata} 
	V modulu \texttt{symtable.c} Pro sémantickou analýzu používáme 2 tabulky symbolů.první tabulka se nachází ve struktuře \texttt{symtable\_func}. Tabulka je globální a slouží k uchovávání funkcí a jejich parametrů.druhá tabulka se nachází ve struktuře \texttt{symtable\_var}. Tabulka se používá pro proměné a jejich parametry, přičemž se chápu jako lokální tabulky, které se ukládájí na zásobníku. Zásobník je v modulu \texttt{symstack.c} Naše tabulky symboů jsou implementováný jako tabulky s náhodným rozptýlením. V sémantické analýze se používají ke kontrole definic, dodržení správného typu, návratových hodnot apod.

	\section{Generování cílového kódu}

	Vnitřní kód se genereju v parseru a je velmi podobný cílovému kódu IFJcode20. 
	Je ukládán v lineárním seznamu a každá položka obsahuje instrukci (ta je shodna s instrukcemi IFJcode20) a až 3 symbolické adresy.
	V případě konstanty je místo adresy uložena přímo hodnota konstanty. Jakmile jsou vygenerovány všechny instrukce, 
	tak se nad seznamem mohou provést optimalizace, které ale neprovádíme. Poté se všechny instrukce vypíší na STDOUT a konstanty se převedou do
	požadovaného formatu.

	V modulu \texttt{generator.c} se taky generují symbolické adresy a unikátní jména pro návěští a proměnné. Paramentry funkcí mají
	jména ve tvaru \texttt{\$\_0}, \texttt{\$\_1}, ..., protože při volání funkce není známo jméno parametru, ale víme pořadí, a návratové hodnoty funkcí mají jmena
	ve tvaru \texttt{\$\_ret0}, \texttt{\$\_ret1}, ..., protože návratové hodnoty žádné jména nemají. Unikátnost těchto jmen je zaručena tím že každé funcki se při volání vytvoří
	vlastní lokální rámec.



	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Speciální algoritmy a datové struktury %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Speciální algoritmy a~datové struktury}
	
	\subsection{Tabulka symbolů}
    Tabulka symbolů, ve zdrojových souborech \verb|symtable.c|, slouží k uchování názvů definovaných funkcí a proměnných. Pro nalezení definované položky v řídkém seznamu slouží tzv. hash, který nám řekne, kde se v tabulce tato položka podle názvu nachází. U proměnné můžeme najít její přiřazenou hodnotu a u funkce její jednotlivé argumenty nebo definované proměnné uvnitř této funkce.

    \subsection{Zásobník}
    Používáme zásobník \verb|symstack.c|  v sobě uchovává hodnoty indentů. Zásobník naplňuje lexikální analyzátor a správnost indentů následně kontroluje syntaktický analyzátor.

    \section{Rozšíření}
    \subsection{BASE}
    
    \subsection{BOOLTHEN}
     
    \subsection{UNARY}



	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Práce v týmu %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Práce v~týmu***}

	\subsection{Verzovací systém a plánovací systém}

	Pro správu souborů projektu jsme používali verzovací systém Git. Jako vzdálený repositář jsme používali \mbox{GitHub}.Jednotlivé změny smě průběžne přidávali aby sme mali překladač v tom nejaktuálnějším a zálohovaném stave.

	\subsection{Komunikace}

	Pro komunikaci smě využívali volně stažitelnou aplikaci Discord, kde jsme měli vytvořenou skupinovou komunikaci a vedli jsme pravidelný oficiální meeting jednou do týdne. Neoficiálně jsme vždy komunikovali pomocí textových zprav uvnitř aplikace.

	\subsection{Rozdělení práce mezi členy týmu}

	Na základe rozdělení práce a časové složitosti úkolů jsme procentuální hodnocení 25\,\% rozdělili rovnoměrně. 
	\bigskip
	
	\noindent
Filip Solich
\vspace{-0.6em}
\begin{itemize}
  \item{Lexikální analýza}
  \vspace{-0.6em}
  \item{Generování cílového kódu pro výrazy}
  \vspace{-0.6em}
\end{itemize}
Marek Sechra
\vspace{-0.6em}
\begin{itemize}
  \item{Sémantická analýza}
  \vspace{-0.6em}
  \item{Tabulka symbolů}
\end{itemize}
Andrej Baáš
\vspace{-0.6em}
\begin{itemize}
  \item{Syntaktická analýza}
  \vspace{-0.6em}
  \item{Semantická analýza}
  \vspace{-0.6em}
  \item{Generátor cílového kódu}
\end{itemize}
Matej Mištík
\vspace{-0.6em}
\begin{itemize}
  \item{Dokumentace}
  \vspace{-0.6em}
  \item{Generování návěští cílového kódu }
  \vspace{-0.6em}
\end{itemize}
\bigskip
Dále se každý podílel na tvorbě dokumentace a tvorbě testovacích zdrojových kódů.
	       

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Závěr %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Závěr**}

    Překladač představoval veľkú výzvu a vyžadoval spoluprací všech členů týmu. Získali sme zkušenosti jednak teoretické z datových struktur předmětu IAL a překladačů předmětu IFJ, ale taktéž praktické či už prácou v tíme či postupním vytváraním modulů až po fungující celek. Projekt bol časově náročný, ale úsilí na naň vyvinuté se vrátí v zkušenostech, které smě získali.

\newpage
\appendix

\section{Konečný Automat}

		\begin{figure}[!ht]
		\centering
		\includegraphics[ width=0.8\linewidth]{img/automat.pdf}
		\caption{Konečný automat využitý k implementaci Lexikální analýzy}
		\label{figure:automat}
	\end{figure}


\section{LL Tabulka}

 	\begin{table}[!ht]
	\centering
	 \caption{LL -- tabulka použita syntaktickou analýzou}
		\label{table:ll_table}
	\end{table}
 
	
 \section{LL Gramatika}
 

 \noindent   
 \begin{flushleft}
    1. \texttt{<prolog>} -> \texttt{package main <prog>}

	2. \texttt{<prog>} -> \texttt{EOL <prog>}

	3. \texttt{<prog>} -> \texttt{func ID (<params>) <return\_type> \{ EOL <statement> \} <next\_prog>}

	4. \texttt{<params>} -> \texttt{ID <type> <next\_params>}

	5. \texttt{<params>} -> \texttt{$\epsilon$}

	6. \texttt{<next\_params>} -> \texttt{, ID <type> <next\_params>}

	7. \texttt{<return\_type>} -> \texttt{(<list\_type>)}

	8. \texttt{<return\_type>} -> \texttt{$\epsilon$}

	9. \texttt{<type>} -> \texttt{string}

	10. \texttt{<type>} -> \texttt{float64}

	11. \texttt{<type>} -> \texttt{int}

	12. \texttt{<statement>} -> \texttt{ID <unary> <expression> EOL <statement>}

	13. \texttt{<statement>} -> \texttt{ID <list\_id> = <exp/func> EOL <statement>}

	14. \texttt{<statement>} -> \texttt{<call\_func> EOL <statement>}

	%%15. \texttt{<statement>} -> \texttt{if <expression> NOT\_EOL \{ EOL <statement> \} NOT\_EOL else \{ EOL <statement> \} EOL <statement>}

	15. \texttt{<statement>} -> \texttt{if <expression> NOT\_EOL \{ EOL <statement> \} <else/else\_if> EOL <statement>}

	16. \texttt{<statement>} -> \texttt{for <init> ; <expression> ; <increment> \{ EOL <statement>\} EOL <statement>}

	17. \texttt{<statement>} -> \texttt{$\epsilon$}

	18. \texttt{<list\_id>} -> \texttt{, ID <list\_id>}

	19. \texttt{<list\_id>} -> \texttt{$\epsilon$}

	20. \texttt{<init>} -> \texttt{ID := <expression>}

	21. \texttt{<init>} -> \texttt{$\epsilon$}

	22. \texttt{<increment>} -> \texttt{ID <unary\_for> <expression>}
	
	23. \texttt{<increment>} -> \texttt{ID <list\_id> = <exp/func>}	

	24. \texttt{<increment>} -> \texttt{$\epsilon$}
	
	25. \texttt{<unary\_for>} -> \texttt{ = }

	26. \texttt{<unary\_for>} -> \texttt{ += }

	27. \texttt{<unary\_for>} -> \texttt{ -= }

	28. \texttt{<unary\_for>} -> \texttt{ *= }

	29. \texttt{<unary\_for>} -> \texttt{ /= }

	30. \texttt{<exp/func>} -> \texttt{<expression> <list\_exp>}

	31. \texttt{<exp/func>} -> \texttt{<call\_func>}

	32. \texttt{<list\_exp>} -> \texttt{, <expression> <list\_exp>}

	33. \texttt{<list\_exp>} -> \texttt{$\epsilon$}

	34. \texttt{<call\_func>} -> \texttt{ID (<term>) EOL <statement>}

	35. \texttt{<term>} -> \texttt{<value> <list\_term>}

	36. \texttt{<list\_term>} -> \texttt{, <value> <list\_term>}

	37. \texttt{<list\_term>} -> \texttt{$\epsilon$}

	38. \texttt{<value>} -> \texttt{STRING\_VALUE}

	39. \texttt{<value>} -> \texttt{FLOAT64\_VALUE}

	40. \texttt{<value>} -> \texttt{INT\_VALUE}

	41. \texttt{<value>} -> \texttt{ID}

	42. \texttt{<value>} -> \texttt{$\epsilon$}

	43. \texttt{<statement>} -> \texttt{return <return\_exp> EOL <statement>}

	44. \texttt{<return\_exp>} -> \texttt{<expression> <list\_exp>}

	45. \texttt{<return\_exp>} -> \texttt{$\epsilon$}

	46. \texttt{<list\_type>} -> \texttt{<type> <next\_type>}

	47. \texttt{<list\_type>} -> \texttt{$\epsilon$}

	48. \texttt{<next\_type>} -> \texttt{, <type> <next\_type>}

	49. \texttt{<next\_type>} -> \texttt{$\epsilon$}

	50. \texttt{<next\_prog>} -> \texttt{<prog>}

	51. \texttt{<next\_prog>} -> \texttt{EOF}

	52. \texttt{<unary>} -> \texttt{ := }

	53. \texttt{<unary>} -> \texttt{ += }

	54. \texttt{<unary>} -> \texttt{ -= }

	55. \texttt{<unary>} -> \texttt{ *= }

	56. \texttt{<unary>} -> \texttt{ /= }

	57. \texttt{<type>} -> \texttt{bool}

	58. \texttt{<value>} -> \texttt{BOOL\_VALUE}

	59. \texttt{<else/else\_if>} -> \texttt{ NOT\_EOL else <IF> \{ EOL <statement> \} }

	60. \texttt{<else/else\_if>} -> \texttt{$\epsilon$}

	61. \texttt{<IF>} -> \texttt{if <expression> NOT\_EOL \{ EOL <statement> \} <else/else\_if> }

	62. \texttt{<IF>} -> \texttt{ $\epsilon$ }

	63. \texttt{<next\_params>} -> \texttt{$\epsilon$}
	
	
	   
		
\end{flushleft} 

	\begin{table}[!ht]
	\centering
	 \caption{LL -- gramatika řídící syntaktickou analýzu}
		\label{table:ll_gramatika}
	\end{table}

\section{Precedenční tabulka}



	\begin{table}[!ht]
		\centering
		\includegraphics[width=0.9\linewidth]{img/prec_table.pdf}
		\caption{Precedenční tabulka použitá při precedenční syntaktické analýze výrazů}
		\label{table:prec_table}
	\end{table}
	

\end{document}	
