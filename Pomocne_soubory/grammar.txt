# SUBOR S DERIVACIAMI

# Pravidla:
# - terminaly nesmu mat: < >
# - neterminaly musia mat: < >
# - derivacia je znazornena sipkou: ->

# STARTING NONTERMINAL = <st-list>
1. <st-list> -> <stat> <EOL-EOF>
2. <st-list> -> EOL <st-list>
3. <st-list> -> EOF

4. <EOL-EOF> -> EOL <st-list>
5. <EOL-EOF> -> EOF


6. <stat>    -> def <id-func> <params-gen> <end-list>
7. <stat>    -> <command>


8. <command> -> while **expr** do EOL <end-list>
9. <command> -> if **expr** then EOL <if-list>
10. <command> -> ID <func-assign-expr>

##################################################################################
# EXPRESIONS without assignment
# po najdeni nasledujucich tokenov na zaciatku vstupnej pasky (dostaneme zo scanneru) zapiname preced. a. na prijatie vyrazu
# dolezite je ze v tychto pripadoch musime zahrnut aj tieto tokeny do preced. a.

# expr_include: + - FUNC STR INT DBL nil (
# <command> -> **expr_include** EOL

# ak pride hocico ine ako = zapiname precedenc analyzu
# musime zahrnut predchadzajuci token (ID) 
# expr_include_two: arithmetic: +, -, *, /  relation: ==, !=, <, <=, >, >=
# 
##################################################################################


11. <func-assign-expr> -> = **expr**


# END-LIST
12. <end-list>  -> <command> EOL <end-list>
13. <end-list>  -> EOL <end-list>
14. <end-list>  -> end

15. <if-list>  -> <command> EOL <if-list>
16. <if-list>  -> EOL <if-list>
# po prijati "elif" zapiname precedencnu analyzu na prijatie vyrazu
17. <if-list>  -> elif **expr** then EOL <if-list>
18. <if-list>  -> else EOL <end-list>
19. <if-list>  -> end 


# FUNCTION
20. <id-func>    -> ID
21. <id-func>    -> FUNC

# FUNCTION PARAMETERS
22. <params-gen> -> ( <p-brackets> 
23. <params-gen> -> ID <p-without>
24. <params-gen> -> EOL

25. <p-brackets>   -> ID <p-brackets-cont> 
26. <p-brackets>   -> ) EOL

27. <p-brackets-cont> -> , ID <p-brackets-cont>
28. <p-brackets-cont> -> ) EOL

29. <p-without> -> , ID <p-without> 
30. <p-without> -> EOL



